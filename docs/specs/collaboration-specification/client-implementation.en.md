# Client Implementation

**Document Version**: 1.0  
**Software Version**: 0.1.0  
**Last Updated**: 2026-01-14

---

## 1. SignalingClient

```typescript
class SignalingClient {
  private ws: WebSocket | null = null;
  private roomCode: string | null = null;
  private clientId: string;
  
  constructor(serverUrl: string) {
    this.clientId = generateUUID();
  }
  
  // Room registration (Host) - Room code generated by server (maintained for 6 hours)
  async registerRoom(hostId: string): Promise<string>  // Returns room code
  
  // Enable join permission (Host) - Can be called anytime
  // If called again after expiration, immediately switches to join-allowed state
  async allowJoin(roomCode: string, duration: number): Promise<void>
  
  // Kick participant (Host)
  async kickParticipant(roomCode: string, participantId: string): Promise<void>
  
  // Join room (Participant)
  async joinRoom(roomCode: string): Promise<HostInfo>
  
  // Send signaling message
  sendSignalingMessage(message: SignalingMessage): void
  
  // Register callback for receiving signaling messages
  onSignalingMessage(callback: (message: SignalingMessage) => void): void
  
  // Disconnect
  disconnect(): void
}
```

**Notes:**
- Server URL is resolved from `VITE_COLLABORATION_SERVER_URL` (fallback: `http://10.0.0.79:3000`).
- WebSocket URL uses `VITE_COLLABORATION_WS_URL` and connects to `/api/online-daw/signaling?clientId=...`.
- REST APIs include `X-Client-Id` (and `X-Host-Id` on room registration).

## 2. WebRTCManager

**Host Side (Star Topology):**

```typescript
class HostWebRTCManager {
  private peerConnections = new Map<string, RTCPeerConnection>(); // Connections per guest
  private dataChannels = new Map<string, RTCDataChannel>();
  
  constructor(iceServers: RTCConfiguration) {
    // Host manages connections with multiple guests
  }
  
  // Add guest (when receiving offer)
  async addGuest(guestId: string, offer: RTCSessionDescriptionInit): Promise<RTCSessionDescriptionInit>
  
  // Callback when guest connection completes
  onGuestConnected(callback: (guestId: string) => void): void
  
  // Broadcast message to other guests
  broadcastToOthers(senderId: string, message: P2PMessage): void
  
  // Broadcast message to all guests
  broadcastToAll(message: P2PMessage): void
  
  // Send message to specific guest
  sendToGuest(guestId: string, message: P2PMessage): void
  
  // Disconnect guest
  removeGuest(guestId: string): void
}
```

**Guest Side:**

```typescript
class GuestWebRTCManager {
  private peerConnection: RTCPeerConnection | null = null;
  private dataChannel: RTCDataChannel | null = null;
  
  constructor(iceServers: RTCConfiguration) {
    // Guest connects only to host
  }
  
  // Connect to host (create offer)
  async connectToHost(hostId: string): Promise<RTCSessionDescriptionInit>
  
  // Send message to host
  sendToHost(message: P2PMessage): void
  
  // Callback for receiving message from host
  onMessageFromHost(callback: (message: P2PMessage) => void): void
  
  // Disconnect
  disconnect(): void
}
```

## 3. SyncManager

**Host Side:**

```typescript
class HostSyncManager {
  private webRTCManager: HostWebRTCManager;
  private projectState: ProjectState;
  
  constructor(webRTCManager: HostWebRTCManager) {
    this.webRTCManager = webRTCManager;
  }
  
  // When new guest connects, send initial state
  onGuestConnected(guestId: string): void {
    this.webRTCManager.sendToGuest(guestId, {
      type: 'initial-state',
      data: {
        projectState: this.projectState,
        isInitial: true
      }
    });
  }
  
  // Broadcast local changes to all guests
  broadcastChange(change: RemoteChange): void {
    this.webRTCManager.broadcastToAll({
      type: 'change',
      data: { change }
    });
  }
  
  // Receive changes from guest â†’ Broadcast to other guests
  onGuestChange(guestId: string, change: RemoteChange): void {
    // Resolve conflicts
    const resolved = this.resolveConflict(change);
    // Update project state
    this.applyChange(resolved);
    // Broadcast to other guests
    this.webRTCManager.broadcastToOthers(guestId, resolved);
  }
}
```

**Guest Side:**

```typescript
class GuestSyncManager {
  private webRTCManager: GuestWebRTCManager;
  private projectState: ProjectState;
  
  constructor(webRTCManager: GuestWebRTCManager) {
    this.webRTCManager = webRTCManager;
  }
  
  // Receive initial state after P2P connection is established
  onP2PConnected(): void {
    // Request state when DataChannel opens
    this.webRTCManager.sendToHost({ type: 'state-request' });
    this.webRTCManager.onMessageFromHost((message) => {
      if (message.type === 'initial-state') {
        this.applyProjectState(message.data.projectState);
      } else if (message.type === 'change') {
        this.onHostChange(message.data.change);
      }
    });
  }
  
  // Receive changes from host
  onHostChange(callback: (change: RemoteChange) => void): void {
    this.webRTCManager.onMessageFromHost((message) => {
      if (message.type === 'change') {
        callback(message.data.change);
      }
    });
  }
  
  private applyProjectState(state: ProjectState): void {
    // Completely replace with host's project state
    setProject(state);
    notifyProjectChange({ type: 'project-replaced' });
  }
}
```

---

